<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D文字球</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #e3e9f1; /* Change background color here */
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            cursor: grab;
        }

        body:active {
            cursor: grabbing;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 16px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 200;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: radial-gradient(circle, #fff, #e3e9f1);
            border-radius: 50%;
            pointer-events: none;
            animation: float 6s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); opacity: 0; }
            50% { transform: translateY(-100px) rotate(180deg); opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading">正在加载3D场景...</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // 场景初始化
        let scene, camera, renderer, controls;
        let textSphere, particles = [];
        let mouseX = 0, mouseY = 0;
        let targetRotationX = 0, targetRotationY = 0;
        let currentRotationX = 0, currentRotationY = 0;
        let damping = 0.05;

        // 文字内容
        const texts = [
            "sunldigv3","sunldigv3","sunldigv3","sunldigv3","sunldigv3",
            "sunldigv3","sunldigv3","sunldigv3","sunldigv3","sunldigv3",
            "sunldigv3","sunldigv3","sunldigv3","sunldigv3","sunldigv3",
            "sunldigv3","sunldigv3","sunldigv3","sunldigv3","sunldigv3"
        ];

        function init() {
            // 创建场景
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 100, 1000);

            // 创建相机
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 200);

            // 创建渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x000000, 0);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);

            // 创建文字球
            createTextSphere();

            // 创建粒子系统
            createParticleSystem();

            // 创建光源
            createLights();

            // 设置控制器
            setupControls();

            // 添加事件监听器
            addEventListeners();

            // 隐藏加载提示
            document.getElementById('loading').style.display = 'none';

            // 开始动画循环
            animate();
        }

        function createTextSphere() {
            const group = new THREE.Group();
            const radius = 80;
            const textGeometry = new THREE.TextGeometry('A', {
                size: 8,
                height: 2,
                curveSegments: 12,
                bevelEnabled: true,
                bevelThickness: 0.5,
                bevelSize: 0.3,
                bevelOffset: 0,
                bevelSegments: 5
            });

            texts.forEach((text, index) => {
                const phi = Math.acos(-1 + (2 * index) / texts.length);
                const theta = Math.sqrt(texts.length * Math.PI) * phi;

                const x = radius * Math.cos(theta) * Math.sin(phi);
                const y = radius * Math.sin(theta) * Math.sin(phi);
                const z = radius * Math.cos(phi);

                const textMesh = new THREE.Mesh(
                    textGeometry.clone(),
                    new THREE.MeshPhongMaterial({
                        color: 0x000000,  // Set text color to black
                        transparent: true,
                        opacity: 0.8,
                        shininess: 100
                    })
                );

                textMesh.position.set(x, y, z);
                textMesh.lookAt(0, 0, 0);
                textMesh.castShadow = true;
                textMesh.receiveShadow = true;

                // Create black text label
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                context.fillStyle = 'black';  // Set the text color to black
                context.font = 'bold 32px Arial';
                context.textAlign = 'center';
                context.fillText(text, 128, 40);

                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(20, 5, 1);
                sprite.position.copy(textMesh.position);
                sprite.position.multiplyScalar(1.2);

                group.add(textMesh);
                group.add(sprite);
            });

            textSphere = group;
            scene.add(textSphere);
        }

        function createParticleSystem() {
            const particleCount = 1000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 1000;
                positions[i + 1] = (Math.random() - 0.5) * 1000;
                positions[i + 2] = (Math.random() - 0.5) * 1000;

                colors[i] = Math.random();
                colors[i + 1] = Math.random();
                colors[i + 2] = Math.random();
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 2,
                vertexColors: true,
                transparent: true,
                opacity: 0.6
            });

            const particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function createLights() {
            // 环境光
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);

            // 点光源
            const pointLight = new THREE.PointLight(0xffffff, 1, 300);
            pointLight.position.set(100, 100, 100);
            pointLight.castShadow = true;
            scene.add(pointLight);

            // 聚光灯
            const spotLight = new THREE.SpotLight(0x00ffff, 1);
            spotLight.position.set(-100, 100, -100);
            spotLight.angle = Math.PI / 4;
            spotLight.penumbra = 0.1;
            spotLight.decay = 2;
            spotLight.distance = 200;
            spotLight.castShadow = true;
            scene.add(spotLight);
        }

        function setupControls() {
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 50;
            controls.maxDistance = 300;
            controls.maxPolarAngle = Math.PI;
        }

        function addEventListeners() {
            // 鼠标移动事件
            document.addEventListener('mousemove', onMouseMove);
            
            // 触摸事件
            document.addEventListener('touchstart', onTouchStart);
            document.addEventListener('touchmove', onTouchMove);
            
            // 窗口大小调整
            window.addEventListener('resize', onWindowResize);
        }

        function onMouseMove(event) {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            
            targetRotationX = mouseY * 0.5;
            targetRotationY = mouseX * 0.5;
        }

        function onTouchStart(event) {
            event.preventDefault();
        }

        function onTouchMove(event) {
            event.preventDefault();
            if (event.touches.length === 1) {
                const touch = event.touches[0];
                mouseX = (touch.clientX / window.innerWidth) * 2 - 1;
                mouseY = -(touch.clientY / window.innerHeight) * 2 + 1;
                
                targetRotationX = mouseY * 0.5;
                targetRotationY = mouseX * 0.5;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // 应用阻尼效果
            currentRotationX += (targetRotationX - currentRotationX) * damping;
            currentRotationY += (targetRotationY - currentRotationY) * damping;

            // 旋转文字球
            if (textSphere) {
                textSphere.rotation.x = currentRotationX;
                textSphere.rotation.y = currentRotationY;
            }

            // 更新控制器
            controls.update();

            // 渲染场景
            renderer.render(scene, camera);
        }

        // 创建浮动粒子效果
        function createFloatingParticles() {
            for (let i = 0; i < 20; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + 'vw';
                particle.style.animationDelay = Math.random() * 6 + 's';
                particle.style.animationDuration = (Math.random() * 3 + 4) + 's';
                document.body.appendChild(particle);
            }
        }

        // 页面加载完成后初始化
        window.addEventListener('load', () => {
            init();
            createFloatingParticles();
        });
    </script>
</body>
</html>
